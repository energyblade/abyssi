package com.badlogic.Abyssi;
//IMPORT PACKAGES
import java.util.Iterator;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.ScreenUtils;
import com.badlogic.gdx.utils.TimeUtils;
import com.mygdx.abyssi.Abyssi;
import com.mygdx.abyssi.Enemy;
import com.mygdx.abyssi.Player;

public class GameScreen implements Screen{
	final Abyssi game;
	//DECLARE VARIABLES
	public SpriteBatch batch; 
	public Sprite knightS;
	private Texture knight, goblin, sword;
	private OrthographicCamera camera;
	
	public Rectangle tempP, tempS;
	
	private Array<Enemy> enemies;
	private int maxMonsters = 5;
	private int currentMonsters = 0;
	public Player P = new Player();
	
	public int gracePeriod = 0;
	public boolean grace = false;
	public boolean monstersSpawned = false;
	public boolean fightingRoom = true, isFighting = false;
	
	public GameScreen(final Abyssi game) {
		this.game = game;
		

		Pixmap pm = new Pixmap(Gdx.files.internal("crosshair.png"));
		Gdx.graphics.setCursor(Gdx.graphics.newCursor(pm, 0, 0));
		pm.dispose();
		
		//INITIALIZE TEXTURES
		knight = new Texture("knight.png");
		goblin = new Texture("goblin.png");
		sword = new Texture("sword.png");
		knightS = new Sprite(knight);

		camera = new OrthographicCamera();
		camera.setToOrtho(false, 1920, 1080);
		batch = new SpriteBatch();
	
		//INITILIZE ENEMIES
		enemies = new Array<Enemy>();
		for (int i = 0; i < maxMonsters; i++) {
			spawnMonster();
		}

	}
	//SPAWN ENEMIES
	private void spawnMonster() {
		Enemy enemy = new Enemy(1, 100, 20, MathUtils.random(64, 1800), MathUtils.random(0, 500), true, 0);
		enemy.setHealth(0);
		enemies.add(enemy);
	}
	//RESPAWN ENEMIES
	private void respawnMonsters() {
		for (Enemy enemy : enemies) {
			System.out.println("reviving...");
			enemy.setHealth(100);
			enemy.setPos(MathUtils.random(64, 1800), MathUtils.random(400, 900));
		}
	}
	
	@Override
	public void render(float delta) {
		///CAMERA
		ScreenUtils.clear(0, 0, 0.2f, 1);
		camera.update();
		batch.setProjectionMatrix(camera.combined);
		
		//MOUSE INPUT
		Vector3 mousePos = camera.unproject(new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0));
		
		//DRAW EVERYTHING ONTO THE SCREEEN
		batch.begin();
		
		for (Enemy enemy : enemies) {
			if (enemy.getIsAlive()) {
				batch.draw(goblin, enemy.getXPos(), enemy.getYPos());
			}

		}
		
		P.move(mousePos.x, mousePos.y);
		roomEvents();

		knightS.setPosition(P.getPlayerRectX(), P.getPlayerRectY());
		P.setDegrees(mousePos.x, mousePos.y);
		knightS.setRotation(P.getDegrees());
		knightS.draw(batch);
		batch.draw(sword, P.getSwordRectX(), P.getSwordRectY());
		// batch.draw(knight, player.x, player.y);
		batch.end();
		
	}
	//WHAT IS HAPPENING IN THE ROOM ATM
	private void roomEvents() {
		if(grace != true && fightingRoom) {
		enemyPhysics();
		
		}else if(gracePeriod > 0 && fightingRoom) {
			gracePeriod --;
			if(gracePeriod == 0) {
				grace = false;
				isFighting = true;
				respawnMonsters();
			}
		}
		
		if(fightingRoom && isFighting == false) {
			if(P.getPlayerRectY() > 900 && P.getPlayerRectX() < 1000 && P.getPlayerRectX() > 600) {
				P.setPlayerRectX(1980 / 2);
				P.setPlayerRectY(100);
				System.out.println("Changing room");
				grace = true;
				gracePeriod = 360;
			}
		}
	}
	//ENEMY BEHAVIOUR
	public void enemyPhysics() {
	//SEARCHING FOR ENEMIES
			for (Enemy enemy : enemies) {
			if (enemy.getIsAlive()) {
				enemy.searchForPlayer(knightS);
				enemy.move();
			}
		}
		
		tempP = P.getPlayerRect();
		tempS = P.getSwordRect();
		
		//HIT ENEMY
		for (Enemy enemy : enemies) {
			if (tempS.overlaps(enemy.getRectangle()) && Gdx.input.justTouched() && enemy.getInvincible() != true) {
				//System.out.println("test");
				enemy.damage(P.getAttack(), knightS);
				//System.out.println("hit enemy");
			}
			//KNOCKBACK
			if(tempP.overlaps(enemy.getRectangle()) && P.getIsInvincible() != true) {
				if (tempP.getX() > enemy.getXPos()) {
					P.setXMs(500);
					P.setIsInvincible(true);
				} else if (tempP.getX() < enemy.getXPos()) {
					P.setIsInvincible(true);
					P.setXMs(-500);
				}

				if (tempP.getY() > enemy.getYPos()) {
					P.setIsInvincible(true);
					P.setYMs(500);
				} else if (tempP.getY() < enemy.getYPos()) {
					P.setIsInvincible(true);
					P.setYMs(-500);
				}
			}
		}
		
		currentMonsters = 0;
		for(Enemy enemy : enemies) {
			if(enemy.getIsAlive()) {
				currentMonsters ++;
				enemy.clockInvincibility();
			}
		}
		//ALL ENEMIES ARE DEAD
		if (currentMonsters == 0) {
			isFighting = false;
		}
		
		
		
		
	}
	
	@Override
	public void resize(int width, int height) {
	}

	@Override
	public void show() {

	}

	@Override
	public void hide() {
	}

	@Override
	public void pause() {
	}

	@Override
	public void resume() {
	}
	//DISPOSE OF EVERYTHING
	@Override
	public void dispose() {
		batch.dispose();
		knight.dispose();
	}
}
